## **EASYLT框架使用手册 v3.0（简称EL3）**



[TOC]

####  **前言**

- #####                        EASYLT框架采用全新的MSVP架构，MSVP是MVC/MVP架构的升级版，在原有的model层中增加server层，可实现业务代码内存常驻，用于多进程、协程的TCP、UDP、HTTP、WEBSOCKET通信协议服务及RPC服务搭建，可快速实现业务RESTful、RPC的API及覆盖web、小程序、APP等各种开发应用场景。

- #####                        EASYLT全名EasyLite，简称EL+版本号（如历史、当前版本为v 3.x、v5.x，则分别称为EL3、EL5）寓意为简单、轻松、优雅的开发、维护项目，在倡导无代码、低代码的大环境下，无论是初学者还是资深开发者，都可快速上手完成项目的业务需求及进阶开发。EASYLT从项目健壮性、应用层面出发，有针对性的选择三方开源扩展、中间件，如消息队列中间件封装了RabbitMQ，更多同类中间件，如Kafka，如果有开发需求可以自行实现。

- #####                        使用前请仔细阅读以下文档，ORM（MySQL）、Swoole、RabbitMQ框架文档部分在使用时再阅读。对于之前使用过MVC架构的开发者可在30分钟内掌握框架。



#### **EASYLT目录结构**

#### | – application

​        **| –** **model**

​               |–  server

​                     | –  server.ini 

​                            (服务配置文件)

​                     | –  connect.ini 

​                            (DB连接配置文件)

​                     | –  (你的服务业务实现)

​               | –  (你的模型业务实现)

​        **| – presenter**

​               | – controller

​                     | –  Index.php  

​                            (Index控制器)

​                     | –  mysql_connect_errors.log 

​                            (mysql连接错误日志)

​                     | –  mysql_errors.log

​                            (mysql执行错误日志)

​               | – logic

​                      | –  (你的逻辑业务实现)

​               | – index.html

​                      | –  (目录保护，勿删)

​        **| – view**

​               | – start.php

​                     (VIEW视图起始文件)

​               | – (你的视图业务实现)

​        **| – index.html**

​               | –  (目录保护，勿删)

#### | – backup

​       (备份文件目录)

#### | – core

​       **| – config**

​              | – config.php

​                    (全局配置文件，如数据库连接参数等)

​              | – config_controller.php

​                    (控制器配置文件)

​              | – config_route.php

​                    (路由配置文件)

​              | – config_swoole.php

​                    (swoole服务配置文件)

​              | – config_rabbitmq.php

​                    (rabbitmq服务配置文件)

​       **| – lib**

​              | – CharCode.php

​                     (图文验证码)   

​              | – DownLoad.php

​                     (文件、图片下载)   

​              | – UpLoad.php

​                     (图片上传)   

​              | – FetchIp.php

​                     (获取访问者IP地址)   

​              | – IsMobile.php

​                     (判断访问者设备类型 PC/MOBILE)   

​              | – CheckPort.php

​                     (验证端口是否被占用)  

​       **| – log**

​                     (捕获异常日志请写入该文件中，可根据需求自定义多个log文件)

​       **| – static**

​              | – Connect_mysql.php

​                     (mysql连接类库)   

​              | – Connect_redis.php

​                     (redis连接类库)   

​              | – Curl.php

​                     (CURL-post请求类库)   

​              | – Curl_get.php

​                     (CURL-get请求类库)   

​              | – Inter.php

​                     (API数据出参类库)   

​              | – Orm.php

​                     (mysql-ORM对象关系映射类库)   

​              | – Tcp_client.php

​                     (TCP客户端类库)   

​              | – Tcp_server.php

​                     (TCP服务器类库)   

​              | – Udp_client.php

​                     (UDP客户端类库)   

​              | – Udp_server.php

​                     (UDP服务器类库)   

​              | – Http_client.php

​                     (HTTP客户端类库)   

​              | – Http_server.php

​                     (HTTP服务器类库)   

​              | – Websocket_server.php

​                     (WEBSOCKET服务器类库)   

​              | – Rpc_client.php

​                     (RPC客户端类库)   

​              | – Rpc_server.php

​                     (RPC服务器类库)   

​              | – Process.php

​                     (多进程创建类库)   

​              | – Simple_producter.php

​                     (RabbitMQ-Simple/Worker模式生产者类库)   

​              | – Simple_consumer.php

​                     (RabbitMQ-Simple/Worker模式消费者类库)   

​              | – Fanout_producter.php

​                     (RabbitMQ-Fanout模式生产者类库)   

​              | – Fanout_consumer.php

​                     (RabbitMQ-Fanout模式消费者类库)

​              | – Routing_producter.php

​                     (RabbitMQ-Routing模式生产者类库)   

​              | – Routing_consumer.php

​                     (RabbitMQ-Routing模式消费者类库) 

​              | – Topic_producter.php

​                     (RabbitMQ-Topic模式生产者类库)   

​              | – Topic_consumer.php

​                     (RabbitMQ-Topic模式消费者类库) 

​              | – Dead_producter.php

​                     (RabbitMQ-死信队列模式生产者类库)   

​              | – Dead_consumer.php

​                     (RabbitMQ-死信队列模式消费者类库)          

​       **| – base.php**

​             (VIEW视图、API数据返回运行基类)   

​       **| – route.php**  

​             (路由解析文件)

​       **| – controller.php**  

​             (控制器解析文件)

#### | – extend

​       (扩展类库目录)

#### | – public

​       **| – index.php**

​             (入口文件)

​       **| – assets**

​             (view视图的静态加载文件，如css、js、img等)

**| – .htaccess**  

​       (Apache路由重写，勿删勿改)

**| – nginx.htaccess**    

​       (Nginx路由重写，勿删勿改)

**| – index.html**

​      (未配置.htaccess/nginx.htaccess服务器定向入口文件)



#### **框架部署**

- 将下载的框架文件复制到LAMP、WAMP、LNMP或WNMP运行环境的运行目录下（如：路径/www），并设置站点运行目录为框架根目录（easylt框架根目录名称，可更改。）

  **PS：运行目录错误将无法正常运行框架**

- 仅支持php7.0及以上版本，否则运行可能会报错。

  

#### **使用框架**

------



##### 配置文件

请打开core/config目录，对所有配置文件进行相应的修改配置，如mysql、redis数据库连接参数等；另外请在config.php中配置更改常量ADDRESS为你的服务器公网IP或域名配置，请以http://或https://开头。



##### 框架运行

打开浏览器输入127.0.0.1，运行成功会出现以下页面：

![](http://easylt.cn/public/assets/frame_run.png)

##### 框架变量

- **$request**

  【应用层：model】请求的入参数据，数据类型为array，根据键值对取值。如API入参的json字符串数据为

    {"username":"liteng"}，则在model文件中$request['username']的值为liteng。

- **$response**

  【应用层：controller、model、logic】在controller、model或logic文件中的API出参回传数据变量，且格式 

    如下：

    $response = [200,'success',$data];第一个参数为code【必须为int数据类型】、第二个参数为message【必  

    须为string数据类型】、第三个参数为返回的数据。

- **$query_model**

  【应用层：controller】用于创建自定义控制器时，类实例化对象根据API请求URL中model模型文件名调用控

    制器类方法，如以下API请求URL：

    http://127.0.0.1/m/v/p/example/login ，则解析后$query_model()等于login()。

- **$query_param**

  【应用层：model】用于判断同一model文件下多接口业务分发对接，如以下API请求URL：

    http://127.0.0.1/m/v/p/example/login/one ，$query_param的值为one。

- **$query_get**

  【应用层：controller、model、logic】获取API请求URL中的GET参数，数据类型为array，根据键值对取

    值。如以下URL：

    http://127.0.0.1/m/v/p/example/login/frame=easylt&username=liteng ，

    $query_get['frame']的值为easylt，$query_get['username']的值为liteng。

- **$mysql_conn**

  【应用层：model、server】mysql连接变量，采用mysqli面向过程写法，在model、server目录文件中使

    用。

- **$mysql_orm**

  【应用层：model】mysql-orm操作变量，仅可在model目录文件中使用。

- **$redis**

  【应用层：model、server】redis连接变量，在model、server目录文件中使用。

- **$curl_post**

​       【应用层：controller、model、logic】curl数据传输post请求模式，应用示例如下：

​         $result = $curl_post->post($url,$data)，第一个参数为目标文件的url、第二个参数为发送的数据，$result 

​         为请求返回值。

- **$curl_get**

​       【应用层：controller、model、logic】curl数据传输get请求模式，应用示例如下：

​         $result = $curl_get->get($url)，参数为目标文件的url，$result为请求返回值。



##### 框架常量

常量值可在core/config目录下的config.php中进行配置

- **ADDRESS：**服务器公网IP或域名，如http://www.easylt.cn
- **API_URL：**Index通用控制器下的API接口地址，Apache/Nginx服务器请支持.htaccess/nginx.htaccess。在VIEW视图中请求API时，在API_URL常量后拼接接口名称（model模型文件名），如API_URL.'login'。
- **API_URL_OTHER：**同上，当Apache/Nginx服务器不支持.htaccess/nginx.htaccess时，用此常量。
- **VIEW_PUBLIC：**入口加载文件地址，Apache/Nginx服务器请支持.htaccess/nginx.htaccess。加载VIEW视图时，在VIEW_PUBLIC常量后拼接view视图文件名，如VIEW_PUBLIC.'login'。
- **VIEW_PUBLIC_OTHER：**同上，当Apache/Nginx服务器不支持.htaccess/nginx.htaccess时，用此常量。
- **STATIC：**view视图静态资源路径，地址指向/public/assets/。
- **D：**路径分隔符



##### 模型（model）

**1、model模型目录下的文件命名规范：文件名不支持大写字母。**

2、model模型下用于实现业务实体类模型，实体类中对关系型数据库mysql操作可采用ORM或mysqli原生写法；对非关系型数据库redis采用原生写法。

**3、API出参回传数据变量命名为$response且格式如下：**

**$response = [200,'success',$data];第一个参数为code【必须为int数据类型】、第二个参数为message【必须为string数据类型】、第三个参数为返回的数据。**

**PS：**

- **API出参回传数据统一自动返回json字符串格式**
- **默认在logic逻辑文件中API出参回传数据，如果model模型文件没有对应的logic逻辑文件，请在model模型文件或controller自定义控制器中返回API数据出参回传。**

4、model模型复用：msvp架构模式下的logic逻辑是为了model模型复用同时与控制器解耦，使得项目大部分情况可以采用一个默认Index控制器，业务逻辑单元放置到logic逻辑中，业务更改仅需对logic逻辑操作即可；如需复用model模型直接在model模型目录下创建文件并include()引入需要复用的model模型文件即可，同理如果没有对应的logic逻辑文件，请在model模型文件或controller自定义控制器中返回API数据出参回传，否则请在logic逻辑中返回API数据出参回传。

**PS：被复用的model文件不能直接数据出参回传，请默认都在对应logic文件中数据出参回传。**



##### 服务（server）

用于创建各种通信协议服务器等内存常驻服务，请参考以下**Swoole、RabbitMQ框架操作**。



##### 视图（view）

**1、view视图目录下的文件命名规范：文件名不支持大写字母及后缀名为.php的文件，如果文件中包含html、css、js代码，仍然后缀名为.php。**

**2、关于view视图资源文件引入：**

- Apache/Nginx服务器支持.htaccess/nginx.htaccess时，view视图文件中引入的资源如js、css、images、fonts等目录/文件请直接放置到框架根目录下，资源文件中的路径无需进行修改。

- 当服务器不支持.htaccess/nginx.htaccess时，view视图文件中引入的资源如js、css、images、fonts等目录/文件请直接放置到框架入口文件public目录下，资源文件中的路径无需进行修改。

  **PS：view视图文件中引入的资源文件也可以放置到public/assets资源目录下，此时需对每个view视图文件中引入资源路径前加上常量STATIC，如果此时引入部分报错请自行调试或采用上面默认的放置方式。**

3、view视图目录下的文件跳转指定页面请调用常量VIEW_PUBLIC并拼接跳转的文件名，不包含扩展名，如跳转到view视图目录下的login.php：

```
echo '<a href='.VIEW_PUBLIC.'login></a>';
```

**PS：**

- **Apache/Nginx服务器请支持.htaccess/nginx.htaccess，否则请替换常量VIEW_PUBLIC为VIEW_PUBLIC_OTHER。**
- **VIEW_PUBLIC常量的值为服务器域名或公网IP+/?href=，如http://127.0.0.1/?href=login**
- **VIEW_PUBLIC_OTHER常量的值为服务器域名或公网IP+/public/?href=，如http://127.0.0.1/public/?href=login**

4、如需要get请求在跳转的文件名后拼接key=value，多参数用&连接，代码中用$_GET['key']取值，如：

```
echo '<a href='.VIEW_PUBLIC.'login&frame=easylt&username=liteng></a>';
```

**PS：Apache/Nginx服务器请支持.htaccess/nginx.htaccess，否则请替换常量VIEW_PUBLIC为VIEW_PUBLIC_OTHER。**

5、view视图下的start.php为起始文件，请更换start.php的代码为项目首页、登录或注册页面。

**PS：请勿更改start.php文件名或删除该文件**



##### 控制（controller）

**1、Index控制器为通用控制器，默认无需创建新的控制器及任何改动，根据以下路由文档说明使用即可。**

2、当业务模块化管理时，可能会自定义创建多个controller控制器，而不依赖于框架自带的Index通用控制器，如下为创建控制器示例：

- 自定义控制器类【可参考以下】

  class Example{

  ​      public function one(){ //类方法名请与model模型文件名对应

  ​              global $response; //$response为model模型或logic逻辑文件中的API出参回传数据

  ​              //函数中写你的业务，默认在logic中完成；

  ​              Response::data($response); //运行API出参回传数据

  ​      }

  ​      public function two(){

  ​              global $response;

  ​              Response::data($response);

  ​      }

  }

​       $ob = new Example; 

​       $ob->$query_model(); //$query_model()为API请求URL中model模型文件名，如以下URL：

​       http://127.0.0.1/m/v/p/example/one ，解析后$query_model()等于one()。



##### 路由（route）

1、控制器路由示例：http://127.0.0.1/m/v/p/example/model/param/key1=value&key2=value

- http://127.0.0.1/m/为application应用目录路径

- v/p/为presenter/controller/控制器目录路径

- example/为控制器文件名，不包含.php扩展名；

- model/为model模型目录下指定文件名，不包含.php扩展名；

- param/为路由参数，用于判断model文件下多接口业务分发对接，可选项；

- key1=value为get请求入参，多参数用&连接，用$query_get['key']取值，可选项；

  **PS：默认已对路由进行重写，Apache/Nginx服务器请支持.htaccess/nginx.htaccess，否则请按照以下写法：**

  http://127.0.0.1/application/presenter/controller/example.php/model/param/?key1=value&key2=value
  
  **PS：如果以下路由重写配置改变了application下各个目录名，则以上URL中的application路径也要相应改变。**

2、控制器路由重写配置：

- 在config_route.php路由配置文件中修改常量ROUTE_RUN的值为1，开启配置运行；

- 在config_route.php路由配置文件中修改常量API_URL_ROUTE的各个值用于API-URL重写；

- 在config_route.php路由配置文件中修改常量APPLICATION_RENAME的各个值用于改变application下各个目录名；

  **PS：修改后目录名为修改的目录名+下划线+目录标识，如controller目录名改为init，则修改后控制器目录名为init_controller；如果将目录名改为初始值，如model、server、presenter、controller、logic、view，则目录名不会拼接+下划线+目录标识，恢复原状。**

- 通过浏览器运行框架入口文件，如访问http://127.0.0.1则以上配置即可生效；

- 在config_route.php路由配置文件中修改常量ROUTE_RUN的值为0，关闭配置运行；

  **PS：路由重写仅对Apache/Nginx服务器支持.htaccess/nginx.htaccess时生效**

**3、服务器.htaccess/nginx.htaccess支持：**

Apache服务器的路由重定向文件为框架根目录下的.htaccess，Nginx服务器的路由重定向文件为框架根目录下的nginx.htaccess。Apache默认支持.htaccess，如果不支持请自行配置解决；Nginx默认不支持nginx.htaccess，请按照以下方法配置：

- 打开Nginx服务器的vhosts.conf，在该配置文件中引入nginx.htaccess，如下标黑部分为引入项，注意路径：

  server {
          listen        80;
          server_name  localhost;
          root   "D:/wamp/www/easylt";
          location / {
              index index.php index.html;
              error_page 400 /error/400.html;
              error_page 403 /error/403.html;
              error_page 404 /error/404.html;
              error_page 500 /error/500.html;
              error_page 501 /error/501.html;
              error_page 502 /error/502.html;
              error_page 503 /error/503.html;
              error_page 504 /error/504.html;
              error_page 505 /error/505.html;
              error_page 506 /error/506.html;
              error_page 507 /error/507.html;
              error_page 509 /error/509.html;
              error_page 510 /error/510.html;
              autoindex  off;
              **include D:/wamp/www/easylt/nginx.htaccess;**
          }
          location ~ \.php(.*)$ {
              fastcgi_pass   127.0.0.1:9000;
              fastcgi_index  index.php;
              fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;
              fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
              fastcgi_param  PATH_INFO  $fastcgi_path_info;
              fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;
              include        fastcgi_params;
          }
  }

- 如果项目采用宝塔等面板，可以复制nginx.htaccess中的内容到站点-设置-伪静态中即可。

- 首次配置nginx.htaccess或后续路由重写都需重启Nginx服务器才可生效。



##### 逻辑（logic）

**1、logic逻辑目录下的文件命名规范：文件名不支持大写字母，logic文件命名为model相应文件名拼接.logic，**如model文件名为login.php，则logic相应文件名必须为login.logic.php。

**2、在logic逻辑文件中写业务可以直接调用响应model模型文件中的变量、方法、类。**



##### **ORM（MySQL）**

1、ORM实现了mysql增删改查常用的操作，避免书写有漏洞的sql、优化实体类结构，如防止sql注入，同时让业务易于理解、更改；如牵扯复杂业务可采用默认的mysqli面向过程原生写法，默认的连接变量为$mysql_conn，或自行创建PDO连接并操作。

**PS：暂不支持事务、悲观锁操作。**

2、首先选择操作模式，写法为：$mysql_orm->model(''); 形参有四种，分别为：insert、delete、update、select，model()方法后调用的方法顺序请按照文档顺序实施，如：$mysql_orm->model('select')->from('*,user')->where('sex=&$nan&')->order_by('id,desc')->limit('0,10')->query();

3、ORM有两种写法，可组装或分组，$mysql_orm->model('select')->from('*,user')->query();为组装写法，以下为分组写法：

​         $mysql_ob = $mysql_orm->model('select');

​         $mysql_ob->from('*,user');

​         $mysql_ob->query();



###### insert写入操作

​         **$mysql_ob = $mysql_orm->model('insert');** //【必填项】选择操作模式为写入

​         **$mysql_ob->table('username&sex,user');** //【必填项】输入写入的字段与表名，用逗号分隔；多字

​         段用&分隔。

​         **$mysql_ob->values('liteng,nan&leiting,nv');** //【与select()方法二选一必填项】输入字段相应写入的

​         值，用逗号分隔；如果写入多条数据请用&分隔；如参数为变量，拼接如下：

​         **$mysql_ob->values($username.','.$sex.'&'.$username2.','.$sex2);**

​         **$mysql_ob->select('select username,sex from user2 where sex=&$nan&');** //【与values()方法

​         二选一必填项】直接输入sql查询语句，条件值无论为变量、常量、%%模糊查询、[]正则查询或直接输入

​         标量都需要包含在&$&中间。

​         **$mysql_ob->query();** //【必填项】返回类型为array，返回成功写入数据行数及写入的主键id，多条数

​         据写入仅返回第一条的主键id。



###### delete删除操作

​         **$mysql_ob = $mysql_orm->model('delete');** //【必填项】选择操作模式为删除

​         **$mysql_ob->table('user');** //【必填项】输入表名

​         **$mysql_ob->where('username=&$'.$username.'& or sex=&$nan&');** //【必填项】条件值无论为变

​         量、常量、%%模糊查询、[]正则查询或直接输入标量都需要包含在&$&中间，如：

​         'username=&$'.$username.'&'或'username=&$liteng&'或'username like &$%李%&'

​         **$mysql_ob->query();** //【必填项】返回类型为array，返回成功删除数据行数。



###### update更新操作

​         **$mysql_ob = $mysql_orm->model('update');** //【必填项】选择操作模式为更新，可多表更新。

​         **$mysql_ob->table('user,user2');** //【必填项】输入表名，多表更新用逗号分隔表名。

​         **$mysql_ob->set('user.sex=&$nv&,user2.sex=&$nv&');** //【必填项】输入更新字段与值，值无论为

​         变量、常量或直接输入标量都需要包含在&$&中间且用逗号分隔每组更新参数。

​         **$mysql_ob->where('user.username=&$'.$username.'& and user2.username=&$.$username2**

​         **.'&');**

​         //【必填项】条件值无论为变量、常量、%%模糊查询 、[]正则查询或直接输入标量都需要包含在&$&中 

​         间，如：

​         'username=&$'.$username.'&'或'username=&$liteng&'或'username like &$%李%&'

​         **$mysql_ob->query();** //【必填项】返回类型为array，返回成功更新数据行数。



###### select查询操作

​         **$mysql_ob = $mysql_orm->model('select');** //【必填项】选择操作模式为查询，支持全连接查询（PHP

​         不支持并行查询，内连接查询、外连接查询请用全连接查询拼接sql串行查询）、子 查询、分组查询、模糊

​         及正则查询；全连接查询、子查询、模糊及正则查询sql语句直接写在where()方法中。

​         **$mysql_ob->from('username&sex,user');** //【必填项】输入字段与表名，用逗号分隔；多字段用&分

​         隔。

​         **$mysql_ob->where('username=&$'.$username.'& or sex=&$nan&');** //【选填项】条件值无论为变

​         量、常量、%%模糊查询、[]正则查询或直接输入标量都需要包含在&$&中间，如：

​         'username=&$'.$username.'&'或'username=&$liteng&'或'username like &$%李%&'

​         **$mysql_ob->group_by('username');** //【选填项】输入分组字段名，from()、order_by()方法中字段要和

​         group_by()中的字段相同，且from()方法中字段格式如下：

​         'username as 姓名&count(product) as 购物次数,user'

​         **$mysql_ob->order_by('username,desc');** //【选填项】输入排序字段名及排序规则-desc\asc，用逗号分

​         隔。

​         **$mysql_ob->limit('0,10');** //【选填项】输入限制结果集参数-offset，num，用逗号分隔，仅输入一个参数

​         则默认为num。

​         **$mysql_ob->query();** //【必填项】返回类型为array，返回数据查询结果。



##### **Swoole框架操作**

1、Swoole是一个多进程、支持协程的客户端、服务器php扩展，支持TCP、UDP、HTTP，WEBSOCKET协议及RPC远程过程调用客户端、服务器的实现。EASYLT对其进行高度封装，使开发变得更简单、可靠。PS：感谢韩天峰老师开发、分享的Swoole开源项目，重新定义PHP。

2、Swoole创建的服务器脱离FPM、WEB服务器运行，可常驻内存，可实现多进程、多协程、异步非阻塞业务，以下将分别说明各个服务器、客户端创建过程。

3、服务运行模型有两种：即**model->model/server**与**view->model/server**

- **model->model/server：**view视图下文件（如AJAX请求）或外部客户端调用API接口映射到model模型目录下的client客户端，model模型目录下的client客户端文件通过TCP等通信协议连接model/server服务器目录下的服务器文件；model/server服务器目录下的server服务器文件仅可通过CLI命令台进行启动。
- **view->model/server：**将client客户端直接创建在view视图目录下，并通过TCP等通信协议连接model/server服务器目录下的服务器文件。

**ps:**

- **view视图下可直接创建websocket、RPC、TCP、UDP、HTTP客户端，但无法操作DB；**

- **model模型下创建的TCP、UDP、HTTP、RPC客户端和常规实体类模型文件一样支持redis、mysqli及mysql的ORM的DB操作；**

- **model-server服务下创建的TCP、UDP、HTTP、WEBSOCKET、RPC服务器仅支持redis、mysqli的原生DB操作，不支持mysql-ORM；任何其他协议服务器的类方法中的回调函数操作数据库均需先载入连接配置文件include('connect.ini')，mysql连接变量为$mysql_conn，redis连接变量为$redis；**

- **默认一种协议服务器仅能创建一次，如果要创建多个相同协议的服务器及服务器下采用不同配置，请在启动一个服务器后，在config_swoole.php中更改端口号并启动一个新的服务器进程，相应的客户端端口号请直接在客户端中更改。**

4、请安装Swoole最新版本扩展到php中并打开core/config目录下的config_swoole.php，对相应的服务器、客户端配置文件进行相应的修改，配置文件中对每一项参数有详细说明。默认已配置好每一项，通常无需再次配置。



###### 创建TCP服务器

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化服务器【必须实现】

  $tcp_serv = new tcp_server;

- 创建服务器【必须实现】

  $tcp_serv->create();

- 当客户端连接成功时触发【可选项】

  $tcp_serv->connect(function(){

  //匿名回调函数中写你的业务

  });

- 当接收到请求数据时【必须实现】

  $tcp_serv->receive(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  //如需给客户端返回数据请return $var

  });

- 处理task异步任务，用于一些耗时的任务，启用时需在config_swoole.php中打开【可选项】

  $tcp_serv->task(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- task异步任务完成事件【如启用task则必须实现】

  $tcp_serv->finish(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- 当客户端关闭成功时触发【可选项】

  $tcp_serv->close(function(){

  //匿名回调函数中写你的业务

  });

- 启动服务器【必须实现】

  $tcp_serv->start();
  
  

###### 创建TCP客户端

- 实例化客户端【必须实现】

  $tcp_cli = new tcp_client;

- 创建连接【必须实现】

​       $tcp_cli->connect();

- 像服务器发送数据【必须实现】

​       $tcp_cli->send(function(){

​       //匿名回调函数中写你的业务

​       //如需发送数据请return $var

​       });

- 从服务器接收数据【必须实现】

  $tcp_cli->recv(function($response_data){

  //$response_data为服务器返回的数据

  //匿名回调函数中写你的业务

  });

- 关闭连接【必须实现】

  $tcp_cli->close();
  
  

###### 创建UDP服务器

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化服务器【必须实现】

  $udp_serv = new udp_server;

- 创建服务器【必须实现】

  $udp_serv->create();

- 当接收到请求数据时【必须实现】

  $udp_serv->packet(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  //如需给客户端返回数据请return $var

  });

- 处理task异步任务，用于一些耗时的任务，启用时需在config_swoole.php中打开【可选项】

  $udp_serv->task(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- task异步任务完成事件【如启用task则必须实现】

  $udp_serv->finish(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- 启动服务器【必须实现】

  $udp_serv->start();
  
  

###### 创建UDP客户端

- 实例化客户端【必须实现】

  $udp_cli = new udp_client;

- 像服务器发送数据【必须实现】

​       $udp_cli->send(function(){

​       //匿名回调函数中写你的业务

​       //如需发送数据请return $var

​       });

- 从服务器接收数据【必须实现】

  $udp_cli->recv(function($response_data){

  //$response_data为服务器返回的数据

  //匿名回调函数中写你的业务

  });
  
  


###### 创建HTTP服务器

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化服务器【必须实现】

  $http_serv = new http_server;

- 创建服务器【必须实现】

  $http_serv->create();

- 当接收到请求数据时【必须实现】

  $http_serv->request(function($request_post,$request_get){

  //$request_post为客户端发送的post请求数据，$request_get为客户端发送的get请求数据；

  //匿名回调函数中写你的业务

  //如需给客户端返回数据请return $var

  });

- 处理task异步任务，用于一些耗时的任务，启用时需在config_swoole.php中打开【可选项】

  $http_serv->task(function($request_post,$request_get){

  //$request_post为客户端发送的post请求数据，$request_get为客户端发送的get请求数据；

  //匿名回调函数中写你的业务

  });

- task异步任务完成事件【如启用task则必须实现】

  $http_serv->finish(function($request_post,$request_get){

  //$request_post为客户端发送的post请求数据，$request_get为客户端发送的get请求数据；

  //匿名回调函数中写你的业务

  });

- 启动服务器【必须实现】

  $http_serv->start();
  
  

###### 创建HTTP客户端

- 实例化客户端【必须实现】

  $http_cli = new udp_client;

- 像服务器发送数据并接收服务器返回数据【必须实现】

​       $result = $http_cli->post(['username'=>'easylt']);//发送post请求，url请在config_swoole.php中配置;

​       $result = $http_cli->get('?username=easylt');//发送get请求，url请在config_swoole.php中配置，这里仅跟

​        参数，如：?username=easylt&work=frame

​       //$result为服务器返回数据




###### 创建WEBSOCKET服务器

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化服务器【必须实现】

  $websocket_serv = new websocket_server;

- 创建服务器【必须实现】

  $websocket_serv->create();

- 当客户端连接成功时触发【可选项】

  $websocket_serv->connect(function(){

  //匿名回调函数中写你的业务

  });

- 当接收到请求数据时【必须实现】

  **//$websocket_serv->receive()中两个匿名函数，第一个是读业务，方法中仅能对数据库进行读操作，第二个是写业务，可以忽略，方法中仅能对数据库进行写操作。**

  $websocket_serv->receive(function($request_data){

  //$request_data为客户端发送的数据

  //如需给客户端返回数据请return $var

  //$websocket_serv->receive(function(){});的方法体中可实现一对一（单聊），一对多（群聊）业务，请在config_swoole.php中配置，默认为单聊模式。

  },function($request_data){

  //$request_data为客户端发送的数据

  //写业务方法中无法返回数据给客户端
  
  });

- 处理task异步任务，用于一些耗时的任务，启用时需在config_swoole.php中打开【可选项】

  $websocket_serv->task(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- task异步任务完成事件【如启用task则必须实现】

  $websocket_serv->finish(function($request_data){

  //$request_data为客户端发送的数据

  //匿名回调函数中写你的业务

  });

- 当客户端关闭成功时触发【可选项】

  $websocket_serv->close(function(){

  //匿名回调函数中写你的业务

  });

- 启动服务器【必须实现】

  $websocket_serv->start();
  
  

###### 创建WEBSOCKET客户端

- websocket客户端直接创建在view视图目录下，具体可参考view视图目录下的websocket_test.php示例。

  

###### 创建RPC服务器

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化服务器【必须实现】

  $rpc_serv = new rpc_server;

- 创建服务器【必须实现】

  $rpc_serv->create();

- 当客户端连接成功时触发【可选项】

  $rpc_serv->connect(function(){

  //匿名回调函数中写你的业务

  });

- 当接收到请求数据时【必须实现】

  $rpc_serv->receive(function($function_name,$function_param){

  //$function_name为客户端请求的方法名，数据类型为string；

  //$function_param为客户端请求的实参，数据类型为array；

  //如客户端RPC调用发送请求数据为'func1(liteng,10)'，则$function_name为func1，$function_param[0]为liteng，$function_param[1]为10，数字索引下标取值。

  //以下为RPC方法定义默认语法示例，统一采用switch 多分支条件结构 ：

   switch($function_name){
          case 'func1': //定义的方法名供客户端调用，以下为方法体用于实现业务；
              $name = $function_param[0];
              $old_num = $function_param[1];
              $int = intval($old_num);
              $num = $int + 20;
              $result = $name.'一共有'.$num.'颗糖果';
              return $result; //如需返回给客户端数据请return $var
          break;
          case 'func2': //定义的方法名供客户端调用，以下为方法体用于实现业务；
              $name = $function_param[0];
              $old_num = $function_param[1];
              $int = intval($old_num);
              $num = $int + 10;
              $result = $name.'一共有'.$num.'颗糖果';
              return $result; //如需返回给客户端数据请return $var
          break;
          default: return '方法调用失败'; //客户端请求不传参的返回值，如需返回给客户端数据请return $var；
      }

  });

- 处理task异步任务，用于一些耗时的任务，启用时需在config_swoole.php中打开【可选项】

  $rpc_serv->task(function($function_param){

  //$function_param为客户端请求的实参，数据类型为array；

  //匿名回调函数中写你的业务

  });

- task异步任务完成事件【如启用task则必须实现】

  $rpc_serv->finish(function($function_param){

  //$function_param为客户端请求的实参，数据类型为array；

  //匿名回调函数中写你的业务

  });

- 当客户端关闭成功时触发【可选项】

  $rpc_serv->close(function(){

  //匿名回调函数中写你的业务

  });

- 启动服务器【必须实现】

  $rpc_serv->start();
  
  

###### 创建RPC客户端

- 实例化客户端【必须实现】

  $rpc_cli = new rpc_client;

- 创建连接【必须实现】

​       $rpc_cli->connect();

- 像服务器发送数据【必须实现】

​       $rpc_cli->send(function(){

​       //匿名回调函数中写你的业务

​       //如需发送数据请return $var

​       });

- 从服务器接收数据【必须实现】

  $rpc_cli->recv(function($response_data){

  //$response_data为服务器返回的数据

  //匿名回调函数中写你的业务

  });

- 关闭连接【必须实现】

  $rpc_cli->close();
  
  

###### 创建多进程

- 仅支持在server目录下服务器文件中创建，有两种创建模式，分别为单独进程模式与进程池模式：**单独进程模**

  **式的进程间通信支持QUEUE消息队列；进程池模式的进程间通信支持PIPE管道。**

  **//通过$process>create()中的第二个参数切换，'single'为单独进程模式，'pool'为进程池模式。**

​      **单独进程模式：**

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化进程【必须实现】

  $process = new process;//多进程运行为异步非阻塞模式，可在每个进程中创建服务器，进程间用QUEUE消息队列通信。

- 创建进程【必须实现】

  $process->create(function($process){**//创建第一个进程**

  //$process为进程对象

  //匿名回调函数中写你的业务

  ​    $process->push(mt_rand(1,9));//写入数据到QUEUE消息队列

  },'single'); **//'single'为单独进程模式，'pool'为进程池模式。**

  $process->create(function($process){**//创建第二个进程**

  ​     $read = $process->pop();//读取消息队列中的数据，多进程消息队列为争抢模式，无法将消息投递给指定

  ​     进程，但消息是共享的，可一次性读取出来。

  ​     echo $read;

  },'single'); **//'single'为单独进程模式，'pool'为进程池模式。**

​       **进程池模式：**

- 引入服务器配置文件【必须实现】

  include('server.ini');

- 实例化进程【必须实现】

  $process = new process;//多进程运行为异步非阻塞模式，进程间用PIPE管道通信。

- 创建进程池【必须实现】

  $process->create(function($process){

  //$process为进程对象

  //匿名回调函数中写你的业务

  //如需写入数据到PIPE管道请return $var

  },'pool'); **//'single'为单独进程模式，'pool'为进程池模式。**

- 读取PIPE管道中的数据【可选项】

  $process->pipe(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取PIPE管道中的数据
  
  });
  
  


###### 创建协程

- 协程仅支持在server目录下服务器、多进程文件中创建，如在TCP服务器中创建，放置在匿名回调函数中：

  include('server.ini');
  $tcp_serv = new tcp_server;
  $tcp_serv->create();
  $tcp_serv->receive(function($request_data){
      include('connect.ini');
      go(function()use($mysql_conn){**//创建协程一**
          co::sleep(5);
  
  **//co::sleep()为模拟IO不阻塞执行，实际开发中IO等待会自动挂起该协程并运行其他协程中的业务。当多个协程进行IO操作时，请为每一个协程配置co::sleep()以避免发生同一时间片资源争抢而导致部分IO执行失败。**
  
  ​        $sql = "insert into swoole(username,content) values('5s run','server')";
  ​        mysqli_query($mysql_conn,$sql);
  
  ​        mysqli_query($mysql_conn);
  
  ​    });
  ​    go(function()use($mysql_conn){**//创建协程二**
  ​        co::sleep(3);
​        $sql = "insert into swoole(username,content) values('3s run','server')";
  ​        mysqli_query($mysql_conn,$sql);
  
  ​        mysqli_query($mysql_conn);
  
  ​    });
  ​    return $request_data;
  });
  $tcp_serv->start();
  
  //以上服务器运行协程一业务执行要5秒，则协程挂起异步执行协程二，此时协程二在3秒后完成，无需等待。
  
  

###### 创建定时任务

- 定时任务仅支持在server目录下服务器、多进程文件中创建，如在TCP服务器中创建，放置在匿名回调函数中：

  include('server.ini');
  $tcp_serv = new tcp_server;
  $tcp_serv->create();
  $tcp_serv->receive(function($request_data){

  **//创建循环执行定时器**

  ​    swoole_timer_tick(2000,function($time_id){
  ​    $mt_rand = mt_rand(1,9);
  ​    if($mt_rand==9){
  ​        swoole_timer_clear($time_id);//清除循环执行定时器
  ​    }
  ​    file_get_contents('https://www.baidu.com');//每隔2秒访问一次百度
  ​    });

  **//单次执行定时器**

  ​    swoole_timer_after(3000,function(){
  ​    file_get_contents('https://www.baidu.com');//2秒后访问一次百度
  ​    });

  **//结合以上两种，若干秒后中止循环执行定时器**

  ​    swoole_timer_tick(2000,function($time_id){
  ​    file_get_contents('https://www.baidu.com');
  ​    });

  ​    swoole_timer_after(3000,function()use($time_id){
  ​    swoole_timer_clear($time_id);//3秒后中止循环执行定时器
  ​    });

  ​    return $request_data;
  });
  $tcp_serv->start();



##### **RabbitMQ框架操作**

1、RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件，亦称面向消息的中间件，可实现以下模式的消息队列业务，同时具有消息确认机制：simple/worker、fanout、routing、topic、dead。EASYLT对其进行高度封装，使开发变得更简单、可靠。

2、RabbitMQ生产者、消费者运行模型：

**生产者**

- **model：**生产者文件在model模型中创建时，view视图下文件（如AJAX请求）或外部客户端调用API接口映射到model模型目录下的生产者文件时，进行消息生产。
- **model/server：**生产者文件在model/server服务中创建时，仅可通过CLI命令台运行，可配合Swoole的各种服务器、多进程实现内存常驻运行进行消息生产。

**消费者**

- **model：**消费者文件仅在simple/worker模式下可在model模型中创建，且**消费模式必须为即刻模式**，请在core/config目录下config_rabbitmq.php中配置。创建后，view视图下文件（如AJAX请求）或外部客户端调用API接口映射到model模型目录下的消费者文件时，进行消息消费。
- **model/server：**消费者文件在model/server服务中创建时，仅可通过CLI命令台运行，可配合Swoole的各种服务器、多进程实现内存常驻运行进行消息消费。

**ps:**

- **model模型下创建的生产者及simple/worker模式的消费者文件和常规实体类模型文件一样支持redis、mysqli及mysql的ORM的DB操作；**

- **model-server服务下创建的生产者、消费者文件仅支持redis、mysqli的原生DB操作，不支持mysql-ORM；在生产者或消费者类方法中的回调函数操作数据库均需先载入连接配置文件include('connect.ini')，mysql连接变量为$mysql_conn，redis连接变量为$redis；**

- **消费者文件创建在Swoole多进程-进程池模式中，消费者消费模式必须为即刻模式，否则会报错。**

  

###### 创建simple/worker模式生产者

​        simple模式的生产者、消费者为一对一；worker模式的生产者、消费者为一对多，多个消费者依次读取、消费消息队列中的消息，请同时开启多个消费者并内存常驻运行，且**消费模式必须为等待模式**，请在core/config目录下config_rabbitmq.php中配置。

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化生产者【必须实现】

  $simple_producter = new simple_producter;

- 创建连接通道【必须实现】

  $simple_producter->connect($v_host,$queue);

  //$v_host为Virtual host用户名

  //$queue为消息队列名称

- 推送消息到队列中【必须实现】

  $simple_producter->push(function(){

  //匿名回调函数中写你的业务

  //推送消息到队列中请return $var

  });
  
  

###### 创建simple/worker模式消费者

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化消费者【必须实现】

  $simple_consumer = new simple_consumer;

- 创建连接通道【必须实现】

  $simple_consumer->connect($v_host,$queue);

  //$v_host为Virtual host用户名

  //$queue为消息队列名称

- 从消息队列中取消息【必须实现】

  $simple_consumer->pop(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取消息队列中的数据

  //读取消息后需确认成功消费消息请return true，否则读取消息后，该条消息仍然保持在消息队列中；

  });
  
  

###### 创建fanout模式生产者

​        fanout模式的生产者、消费者为一对一或一对多，多个消费者同时读取、消费消息队列中的相同的消息，请同时开启多个消费者并内存常驻运行，且**消费模式必须为等待模式**，请在core/config目录下config_rabbitmq.php中配置。

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化生产者【必须实现】

  $fanout_producter = new fanout_producter;

- 创建连接通道【必须实现】

  $fanout_producter->connect($v_host,$exchange);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称

- 推送消息到交换器中【必须实现】

  $fanout_producter->push(function(){

  //匿名回调函数中写你的业务

  //推送消息到交换器中请return $var

  });
  
  

###### 创建fanout模式消费者

- 引入服务器配置文件【仅能在server中创建，必须实现】

  include('server.ini');

- 实例化消费者【必须实现】

  $fanout_consumer = new fanout_consumer;

- 创建连接通道【必须实现】

  $fanout_consumer->connect($v_host,$exchange,$queue);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称，保持与生产者一致；

  //$queue为消息队列名称，默认可不填写该参数，系统会自动创建临时消息队列，消费者文件进程结束后临时消息队列自动删除。如需对消息队列持久化处理，请在core/config目录下config_rabbitmq.php中配置消息队列为持久化模式。

- 从消息队列中取消息【必须实现】

  $fanout_consumer->pop(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取消息队列中的数据

  //读取消息后需确认成功消费消息请return true，否则读取消息后，该条消息仍然保持在消息队列中；

  });
  
  

###### 创建routing模式生产者

​        routing模式的生产者、消费者为一对一或一对多，多个消费者根据routing匹配同时读取、消费消息队列中的相同的消息，请同时开启多个消费者并内存常驻运行，且**消费模式必须为等待模式**，请在core/config目录下config_rabbitmq.php中配置。

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化生产者【必须实现】

  $routing_producter = new routing_producter;

- 创建连接通道【必须实现】

  $routing_producter->connect($v_host,$exchange,$routing);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称

  //$routing为生产者、消费者与消息队列相互匹配的key

- 推送消息到交换器中【必须实现】

  $routing_producter->push(function(){

  //匿名回调函数中写你的业务

  //推送消息到交换器中请return $var

  });
  
  

###### 创建routing模式消费者

- 引入服务器配置文件【仅能在server中创建，必须实现】

  include('server.ini');

- 实例化消费者【必须实现】

  $routing_consumer = new routing_consumer;

- 创建连接通道【必须实现】

  $routing_consumer->connect($v_host,$exchange,$routing,$queue);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称，保持与生产者一致；

  //$routing为生产者、消费者与消息队列相互匹配的key

  //$queue为消息队列名称，默认可不填写该参数，系统会自动创建临时消息队列，消费者文件进程结束后临时消息队列自动删除。如需对消息队列持久化处理，请在core/config目录下config_rabbitmq.php中配置消息队列为持久化模式。

- 从消息队列中取消息【必须实现】

  $routing_consumer->pop(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取消息队列中的数据

  //读取消息后需确认成功消费消息请return true，否则读取消息后，该条消息仍然保持在消息队列中；

  });
  
  

###### 创建topic模式生产者

​        topic模式的生产者、消费者为一对一或一对多，多个消费者根据topic通配符匹配同时读取、消费消息队列中的相同的消息，请同时开启多个消费者并内存常驻运行，且**消费模式必须为等待模式**，请在core/config目录下config_rabbitmq.php中配置。

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化生产者【必须实现】

  $topic_producter = new topic_producter;

- 创建连接通道【必须实现】

  $topic_producter->connect($v_host,$exchange,$topic);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称

  //$topic为生产者、消费者与消息队列相互匹配的通配符

- 推送消息到交换器中【必须实现】

  $topic_producter->push(function(){

  //匿名回调函数中写你的业务

  //推送消息到交换器中请return $var

  });
  
  

###### 创建topic模式消费者

- 引入服务器配置文件【仅能在server中创建，必须实现】

  include('server.ini');

- 实例化消费者【必须实现】

  $topic_consumer = new topic_consumer;

- 创建连接通道【必须实现】

  $topic_consumer->connect($v_host,$exchange,$topic,$queue);

  //$v_host为Virtual host用户名

  //$exchange为消息队列交换器名称，保持与生产者一致；

  //$topic为生产者、消费者与消息队列相互匹配的通配符

  //$queue为消息队列名称，默认可不填写该参数，系统会自动创建临时消息队列，消费者文件进程结束后临时消息队列自动删除。如需对消息队列持久化处理，请在core/config目录下config_rabbitmq.php中配置消息队列为持久化模式。

- 从消息队列中取消息【必须实现】

  $topic_consumer->pop(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取消息队列中的数据

  //读取消息后需确认成功消费消息请return true，否则读取消息后，该条消息仍然保持在消息队列中；

  });
  
  

###### 创建dead（死信队列）模式生产者

​        dead模式的生产者、消费者为一对一或一对多，多个消费者根据routing匹配同时读取、消费消息队列中的相同的消息，请同时开启多个消费者并内存常驻运行，且**消费模式必须为等待模式**，请在core/config目录下config_rabbitmq.php中配置。

- 引入服务器配置文件【仅在server中创建需实现】

  include('server.ini');

- 实例化生产者【必须实现】

  $dead_producter = new dead_producter;

- 创建连接通道【必须实现】

  $dead_producter

  ->connect($v_host,$exchange,$dead_exchange,$routing,$dead_routing,$queue,$dead_queue,$ttl);

  //$v_host为Virtual host用户名

  //$exchange为正常消息队列交换器名称

  //$dead_exchange为死信消息队列交换器名称

  //$routing为生产者、消费者与正常消息队列相互匹配的key

  //$dead_routing为生产者、消费者与死信消息队列相互匹配的key

  //$queue为正常消息队列名称

  //$dead_queue为死信消息队列名称

  //$ttl为正常消息队列中消息的过期时间，后期后自动转入死信消息队列中；

- 推送消息到正常消息队列交换器中【必须实现】

  $dead_producter->push(function(){

  //匿名回调函数中写你的业务

  //推送消息到交换器中请return $var

  });
  
  

###### 创建dead（死信队列）模式消费者

- 引入服务器配置文件【仅能在server中创建，必须实现】

  include('server.ini');

- 实例化消费者【必须实现】

  $dead_consumer = new dead_consumer;

- 创建连接通道【必须实现】

  $dead_consumer->connect($v_host,$dead_exchange,$dead_routing,$dead_queue);

  //$v_host为Virtual host用户名

  //$dead_exchange为死信消息队列交换器名称，保持与生产者一致；

  //$dead_routing为生产者、消费者与死信消息队列相互匹配的key

  //$dead_queue为死信消息队列名称，保持与生产者一致；

  //以上三个参数为死信消息队列参数时，可实现延迟队列，也可以替换三个参数为正常消息队列参数，则可以在消息过期前去正常消息队列中读取、消费消息；

- 从消息队列中取消息【必须实现】

  $dead_consumer->pop(function($response_data){

  //匿名回调函数中写你的业务

  //$response_data为读取消息队列中的数据

  //读取消息后需确认成功消费消息请return true，否则读取消息后，该条消息仍然保持在消息队列中；

  });
  
  

------
​                                                                                                                                   **感谢使用EASYLT     让开发更简单**

​                                                                                                                                   EASYLT官网：http://www.easylt.cn





